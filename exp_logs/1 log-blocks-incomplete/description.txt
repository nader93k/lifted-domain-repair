My notes:
I guess this is the experiment that led to no further grounding because we didn't have precondition relaxation.
"A* iteration 1776" is particularly interesting since we may not see the optimal repairs there.
Look at this part: (unstack c e)', '(put-down b)', '(pick-up d)', '(stack c d)'
It's interesting that the grounder will never produce (stack d c), which is what we need. 


formated plan:
['(unstack c e)', '(put-down c)', '(pick-up d)', '(stack d c)', '(unstack e b)', '(put-down e)', '(unstack b a)', '(stack b d)', '(pick-up e)', '(stack e b)', '(pick-up a)', '(stack a e)']






$$$$  Vanilla ground repair:  $$$$
pick-up,(holding ?x),effPos,1
unstack,(clear ?y),effPos,1


(unstack c e)
(put-down c)
(pick-up d)
(stack d c)
(unstack e b)
(put-down e)
(unstack b a)
(stack b d)
(pick-up e)
(stack e b)
(pick-up a)
(stack a e)



>>>>  A* iteration 729  <<<<

Current node:
Node instance:
Ground actions: ['(unstack c e)', '(put-down b)', '(pick-up d)', '(stack c d)', '(unstack c d)', '(put-down c)', '(unstack b a)', '(stack b b)', '(pick-up b)', '(stack c d)']
Next lifted actions: pick-up
Current repairs:
put-down,(not (holding ?x)),effNeg,-1
stack,(clear ?y),precPos,-1
put-down,(holding ?x),precPos,-1
current state:
[<Atom clear(d)>, <Atom on(c, e)>, <Atom on(c, d)>, <Atom clear(b)>, <Atom on(e, b)>, <Atom holding(b)>, <Atom clear(c)>, <Atom ontable(d)>, <Atom holding(c)>, <Atom ontable(b)>, <Atom on(b, b)>, <Atom on(b, a)>, <Atom ontable(c)>, <Atom handempty()>, <Atom ontable(a)>]
Num neighbour created: 3




>>>>  A* iteration 875  <<<<

Current node:
Node instance:
Ground actions: ['(unstack c e)', '(put-down b)', '(pick-up d)', '(stack c c)', '(unstack b a)', '(put-down c)', '(unstack c c)', '(stack b d)', '(pick-up c)', '(stack c e)', '(pick-up a)']
Next lifted actions: stack
Current repairs:
stack,(clear ?y),precPos,-1
unstack,(clear ?y),effPos,1
put-down,(holding ?x),precPos,-1
current state:
[<Atom clear(d)>, <Atom on(c, e)>, <Atom clear(b)>, <Atom on(e, b)>, <Atom holding(b)>, <Atom clear(c)>, <Atom holding(c)>, <Atom on(b, a)>, <Atom handempty()>, <Atom ontable(a)>, <Atom clear(e)>, <Atom on(b, d)>, <Atom on(c, c)>, <Atom clear(a)>, <Atom ontable(d)>, <Atom ontable(b)>, <Atom ontable(c)>]
Num neighbour created: 10




>>>>  A* iteration 965  <<<<

Current node:
Node instance:
Ground actions: ['(unstack c e)', '(put-down e)', '(pick-up d)', '(stack c c)', '(unstack e b)', '(put-down c)', '(unstack c c)', '(stack c d)', '(pick-up e)', '(stack e e)']
Next lifted actions: pick-up
Current repairs:
pick-up,(clear ?x),precPos,-1
stack,(clear ?y),precPos,-1
put-down,(holding ?x),precPos,-1
current state:
[<Atom on(e, e)>, <Atom clear(d)>, <Atom on(c, e)>, <Atom clear(e)>, <Atom holding(e)>, <Atom on(c, d)>, <Atom on(e, b)>, <Atom on(c, c)>, <Atom clear(c)>, <Atom ontable(d)>, <Atom holding(c)>, <Atom ontable(e)>, <Atom on(b, a)>, <Atom ontable(c)>, <Atom handempty()>, <Atom ontable(a)>]
Num neighbour created: 3



>>>>  A* iteration 1189  <<<<

Current node:
Node instance:
Ground actions: ['(unstack c e)', '(put-down b)', '(pick-up d)', '(stack c b)', '(unstack b a)', '(put-down c)', '(unstack c b)', '(stack c b)', '(pick-up c)', '(stack b e)']
Next lifted actions: pick-up
Current repairs:
unstack,(clear ?y),effPos,1
put-down,(holding ?x),precPos,-1
stack,(clear ?y),effPos,1
current state:
[<Atom clear(d)>, <Atom on(c, e)>, <Atom clear(b)>, <Atom on(e, b)>, <Atom holding(b)>, <Atom clear(c)>, <Atom holding(c)>, <Atom on(c, b)>, <Atom on(b, a)>, <Atom handempty()>, <Atom ontable(a)>, <Atom clear(e)>, <Atom on(b, e)>, <Atom clear(a)>, <Atom ontable(d)>, <Atom ontable(b)>, <Atom ontable(c)>]




>>>>  A* iteration 1515  <<<<

Current node:
Node instance:
Ground actions: ['(unstack c e)', '(put-down e)', '(pick-up d)', '(stack c c)', '(unstack e b)', '(put-down e)', '(unstack c c)', '(stack e d)', '(pick-up e)', '(stack e e)']
Next lifted actions: pick-up
Current repairs:
stack,(clear ?y),precPos,-1
stack,(holding ?x),precPos,-1
put-down,(holding ?x),precPos,-1
current state:
[<Atom on(e, e)>, <Atom clear(d)>, <Atom on(c, e)>, <Atom clear(e)>, <Atom on(e, d)>, <Atom holding(e)>, <Atom on(e, b)>, <Atom on(c, c)>, <Atom clear(c)>, <Atom ontable(d)>, <Atom holding(c)>, <Atom ontable(e)>, <Atom on(b, a)>, <Atom handempty()>, <Atom ontable(a)>]
Num neighbour created: 2





>>>>  A* iteration 1776  <<<<
:action stack
	:precondition (and
		(holding ?x)
		(clear ?y))


Current node:
Node instance:
Ground actions: ['(unstack c e)', '(put-down b)', '(pick-up d)', '(stack c d)', '(unstack b a)', '(put-down b)', '(unstack c d)', '(stack b d)', '(pick-up b)', '(stack b d)']
Next lifted actions: pick-up
Current repairs:
stack,(clear ?y),precPos,-1
stack,(holding ?x),precPos,-1
put-down,(holding ?x),precPos,-1
current state:
[<Atom clear(d)>, <Atom on(c, e)>, <Atom on(c, d)>, <Atom on(b, d)>, <Atom clear(b)>, <Atom on(e, b)>, <Atom holding(b)>, <Atom clear(c)>, <Atom ontable(d)>, <Atom holding(c)>, <Atom ontable(b)>, <Atom on(b, a)>, <Atom handempty()>, <Atom ontable(a)>]
Num neighbour created: 2



>>>>  A* iteration 2225  <<<<

Current node:
Node instance:
Ground actions: ['(unstack c e)', '(put-down b)', '(pick-up b)', '(stack c c)', '(unstack c c)', '(put-down c)', '(unstack c e)', '(stack c c)', '(pick-up c)']
Next lifted actions: stack
Current repairs:
unstack,(clear ?x),effPos,1
put-down,(holding ?x),precPos,-1
unstack,(on ?x ?y),effPos,1
current state:
[<Atom clear(d)>, <Atom on(c, e)>, <Atom clear(b)>, <Atom on(e, b)>, <Atom on(c, c)>, <Atom clear(c)>, <Atom ontable(d)>, <Atom holding(c)>, <Atom ontable(b)>, <Atom on(b, a)>, <Atom ontable(c)>, <Atom handempty()>, <Atom ontable(a)>]
Num neighbour created: 3

