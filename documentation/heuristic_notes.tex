\documentclass[twocolumn]{article}

\usepackage{amsmath}   
\usepackage{xspace}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{natbib}   


\newcommand{\task}{\ensuremath{\Pi}\xspace}
\newcommand{\preds}{\ensuremath{\mathcal{P}}\xspace}
\newcommand{\acts}{\ensuremath{\mathcal{A}}\xspace}
\newcommand{\objects}{\ensuremath{\mathcal{O}}\xspace}
\newcommand{\init}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\goal}{\ensuremath{\mathcal{G}}\xspace}
\newcommand{\vars}{\ensuremath{X}\xspace}
\newcommand{\varRepl}{\ensuremath{\theta}\xspace}

\newcommand{\someVar}{\ensuremath{x}\xspace}
\newcommand{\atoms}{\ensuremath{\preds^{\vars}}\xspace}
\newcommand{\someAtom}{\ensuremath{p(\vec{\someVar})}\xspace}
\newcommand{\someLiftedSet}{\ensuremath{L}\xspace}

\newcommand{\somePred}{\ensuremath{p}\xspace}

\newcommand{\states}{\ensuremath{S}\xspace}
\newcommand{\someState}{\ensuremath{s}\xspace}

\newcommand{\prename}{\ensuremath{pre}\xspace}
\newcommand{\addname}{\ensuremath{add}\xspace}
\newcommand{\delname}{\ensuremath{del}\xspace}
\newcommand{\pre}[1]{\ensuremath{\prename(#1)}\xspace}
\newcommand{\add}[1]{\ensuremath{\addname(#1)}\xspace}
\newcommand{\del}[1]{\ensuremath{\delname(#1)}\xspace}
\newcommand{\arity}[1]{\ensuremath{|#1|}}
\newcommand{\cost}[1]{\ensuremath{c(#1)}\xspace}

\newcommand{\fixPre}{\ensuremath{F^{\prename}}\xspace}
\newcommand{\fixAdd}{\ensuremath{F^{\addname}}\xspace}

\newcommand{\someAct}{\ensuremath{a}\xspace}
\newcommand{\someActSeq}{\ensuremath{\pi}\xspace}


\newcommand{\optimalHeuristic}{\ensuremath{h^{*}_{Rep}}\xspace}
\newcommand{\optimalHeuristicSeq}{\ensuremath{h^{*}_{Seq}}\xspace}

\newcommand{\optimalHeuristicRel}{\ensuremath{h^{+}_{Rep}}\xspace}
\newcommand{\optimalHeuristicSeqRel}{\ensuremath{h^{+}_{Seq}}\xspace}

\newcommand{\relaxedActs}{\ensuremath{\acts^{+}}\xspace}
\newcommand{\relaxedTask}{\ensuremath{\task^{+}}\xspace}

\newcommand{\unary}[1]{\ensuremath{#1_{|1}}\xspace}
\newcommand{\zeroary}[1]{\ensuremath{#1_{|0}}\xspace}


\title{Technical Notes for the heuristic in the paper}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}

\begin{document}
	
	\maketitle
	
	\section{Introduction}
	
	This notes are meant to formalize the parts of the paper I am involved in.
	This aims to make sure that we know we are on the same page.
	I formalize what I have implemented.
	The main aim is to motivate the choices I made.
	But I also added  some observations I made during this, that I found interesting. 
	We should definitely not be as elaborate in the paper.
	
	
	If there is anything unclear let me know. 
	Feel free to put anything you want to recycle into a paper draft.
	(Sorry for not adding proofs, I had no time for that.
	For now you have to trust me.
	I can explain the reasoning in the meeting.
	)
	
	\section{Notation}
	
	\begin{itemize}[noitemsep]
		\item \task denotes planning tasks
		\item \preds denotes predicates
		\item \acts denotes (lifted) actions
		\item \objects denotes objects
		\item \init denotes the initial state
		\item \goal denotes goal
		\item \atoms denotes the set of all (lifted) atoms
		\item \varRepl denotes a full variable replacement to ground a structure
		\item $^+$ is associated with the delete relaxation
		\item \fixPre is some set of atomic repairs that delete preconditions
		\item \fixAdd is some set of atomic repairs that add \addname elements
	\end{itemize}
	
	
	\section{Problem Formulations and Perfect Heuristics}
	
	Let's start by formalizing the perfect heuristic for both settings.
	
	\begin{definition}
		Given a planning task \task the optimal repair heuristic $\optimalHeuristic(\task)$ is the minimal amount of repairs to make \task solvable.
	\end{definition}
	
	\begin{definition}
		Given a planning task \task, lifted action sequence \someActSeq the optimal repair sequence heuristic $\optimalHeuristicSeq(\task, \someActSeq)$ is the minimal amount of repairs to make \task solvable via a grounded action sequence $\varRepl(\someActSeq)$ for some variable replacement \varRepl.
	\end{definition}
	
	This is particularly important, as we are looking for an admissible heuristic, which is defined w.r.t. to the perfect heuristic.
	
	\begin{definition}
		A heuristic $h$ is called admissible for the optimal repair problem if for all planning tasks \task it holds that. $h(\task) \leq \optimalHeuristic(\task)$. 
	\end{definition}
	
	\begin{definition}
		A heuristic $h$ is called admissible for the optimal repair sequence problem if for all planning tasks \task, lifted action sequences \someActSeq it holds that. $h(\task, \someActSeq) \leq \optimalHeuristicSeq(\task, \someActSeq)$. 
	\end{definition}
	
	We can make the instant observation that a given sequence can only increase the perfect heuristic value and so ignoring the sequence can yield an admissible heuristic estimate.
	
	\begin{proposition}
		Given a planning task \task, lifted action sequence \someActSeq, it holds that:
		$$
		\optimalHeuristic(\task) \leq \optimalHeuristicSeq(\task, \someActSeq)
		$$
		I.e.\ the optimal repair heuristic $\optimalHeuristic(\task)$ is bounded by $\optimalHeuristicSeq(\task, \someActSeq)$.
		This implies that $h(\task, \someActSeq) \coloneqq \optimalHeuristic(\task)$ is an admissible heuristic for the repair problem with a lifted action sequence provided.
	\end{proposition}
	
	\section{Feasibility of Computing the Perfect Heuristics}
	
	It should be obvious that computing the optimal heuristics is too hard. 
	Here we formalize this observation.
	
	\begin{definition}
		For any heuristic $h: \states \rightarrow \mathbb{R}$ the decision problem is:
		Given a state $\someState \in \states$ and $\mathit{val} \in \mathbb{R}$, decide if $h(\someState) = \mathit{val}$.
	\end{definition}
	
	
	This is generally as hard as computing a planning task, as there is no repair need iff a plan exists.
	This is EXPSpace-complete \citep{erol:etal:tr-91}.
	
	\begin{theorem}
		Computing $h^*$ is EXPSpace-complete.
	\end{theorem}
	
	Though, the heuristic value range is far more restricted than the classical 
	planning plan length.
	
	\begin{proposition}
		For any planning task \task:
		$$\optimalHeuristic(\task) \leq \min_{\someAct \in \acts}(\arity{\pre{\someAct}} + \arity{\del{\someAct}}) + \arity{\preds}$$
		bounds the optimal repair heuristic value.
	\end{proposition}

	
	\section{Delete Relaxation Heuristics}
	
	
	We have seen that computing \optimalHeuristic and \optimalHeuristicSeq is too hard.
	Therefore we want to derive a heuristic that is simpler to compute.
	A standard step to head into this direction is to relax the task.
	I.e. create a simpler version of the task that has a superset of solutions of the original task.
	
	The arguably most impactful relaxation of classical planning tasks is the delete relaxation \cite{bonet:geffner:aij-01}.
 	It removes all delete effects of actions to make the computations of plans tractable BYLANDER.
	Within the delete relaxation there derived multiple heuristics.
	The main examples are
	$h^{max}$/$h^{add}$\citep{bonet:geffner:aij-01}, 
	$h^{lmcut}$\citep{helmert:domshlak:icaps-09},
	$h^{FF}$\citep{hoffmann:nebel:jair-01},
	$h^{m}$ (TODO: add citation)
	and 
	feasible computations for $h^{+}$ \citep{bonet:helmert:ecai-10,imai:fukunaga:ecai-14}.
	
	This set of heuristics is still highly relevant and competitive.
	A good example is that the winner of the recent Agile track IPC 2023 (TODO: add citation of DecStar 2023), which falls back to $h^{FF}$ when there is no decoupling.
	
	Thus it seems reasonable to center our heuristic in the same promising setting.
	We will see that this will further allow us to derive a efficient task representation.
	
	
	
	\begin{definition}
		The delete relaxation of a planning task
		$\task = (\preds, \objects, \acts, \init, \goal)$
		is obtained as
		$\relaxedTask = (\preds, \objects, \relaxedActs, \init, \goal)$
		where 
		$$
		\relaxedActs = \{
		(\pre{\someAct}, \add{\someAct}, \emptyset, \cost{\someAct}) \mid \someAct \in \acts
		\}
		$$
		is the set of actions obtained by removing the deletes.
	\end{definition}
	
	\begin{definition}
		For a planning task \task and action sequence \someActSeq:
		$\optimalHeuristicRel(\task) := \optimalHeuristic(\relaxedTask)$
		and 
		$\optimalHeuristicSeqRel(\task) := \optimalHeuristicSeq(\relaxedTask)$
		denote the optimal heuristics within the delete relaxation.
	\end{definition}
	
	
	\section{Task Compilation}
	
	I will introduce a compilation that captures repairs in a delete relaxed task.
	The compilation is only capturing \addname repairs, as I will observe in the following that any \prename repair can be converted to an \addname repair.
	(\delname repairs are non-existent in the delete relaxation.)
	
	\begin{corollary}
		For any planning task \task:
		$$\optimalHeuristicRel(\task) \leq \min_{\someAct \in \acts}(\arity{\pre{\someAct}}) + \arity{\preds}$$
		bounds the optimal repair heuristic value within the delete relaxation.
	\end{corollary}
	
	\begin{proposition}
		Let \relaxedTask be a delete relaxed planning task with at least one applicable action in its initial state.
		Let \fixPre be atomic precondition repairs to make the task solvable.
		Then there is a set \fixAdd with $\arity{\fixPre} \leq \arity{\fixAdd}$ that makes the task solvable.
	\end{proposition}
	
	For now I ignored the case if no action is applicable. 
	We can not do this in the final paper.
	But in this case we should just see which repairs make an action of the next schema applicable. 
	This seems like an easier task to me and would probably prune many other repair options.
	
	So let's continue with the compilation for the case if there is at least one applicable action. 
	In this case we can imply only care about add effect repairs, which we cover by extra actions in the following.
	
	\begin{definition}
		
		$\task = (\preds, \objects, \acts, \init, \goal)$
		is obtained as
		$\task^{R} = (\preds, \objects, \acts^0 \cup \acts^{R}, \init, \goal)$
		where 
		$$
		\acts^0 = \{
		(\pre{\someAct}, \add{\someAct}, \emptyset, 0) \mid \someAct \in \acts
		\}
		$$
		is the set of actions obtained by removing the deletes and setting cost to 0.
		And the repair actions $\acts^{R} = \acts^{R}_1 \cup \acts^{R}_2$ are composed by:
		$$
		\acts^{R}_1 = 
		\{
		(\emptyset, \{\text{activate\_}\somePred\}, \emptyset, 1) \mid \somePred \in \preds
		\}
		$$
		the actions selecting which \addname repairs are selected.
		$$
		\acts^{R}_2
		= \{
		(\{\text{activate\_}\somePred\}, \{\someAtom\}, \emptyset, 0) \mid \somePred \in \preds
		\}$$
		that allow to achieve any atom for the corresponding repair.
	\end{definition}
	
	\begin{theorem}
		$$\optimalHeuristicRel(\task) = \optimalHeuristic(\task^{R})$$
	\end{theorem}
	
	\smallskip
	
	The choice for delete relaxation heuristics is very important to create a task representation one can approach with standard planning techniques.
	The problem for a more general, unrelaxed,  encoding is that grounding would quickly become infeasible.
	The main advantage of the state-of-the-art grounding procedure \citep{helmert:aij-09} comes from only representing all delete relaxed reachable actions. 
	Here all actions become delete relaxed reachable.
	We need these actions in the actual task.
	But for the delete relaxation, \cite{helmert:aij-09} and \cite{correa:etal:icaps-21} showed how to link the task representation to a Datalog representation which can be rewritten to be more space efficient and groundable by 
	benefiting from multiple advancements in Datalog and ASP research.
	(TODO: add citations)
	\cite{correa:etal:icaps-23} backed this by thoroughly analyzing these advancements w.r.t. to grounding planning tasks.
	The observation is that representing the smaller, transformed, delete relaxed version is still possible even in larger scale tasks have too many delete relaxed reachable actions to enumerate.
	
	If we want to make this argument in the paper we should probably compare it to action schema splitting.
	(TODO: add citation)
	
	\section{Feasibility of Computing the Perfect Delete Relaxation Heuristics}
	
	
	
	\begin{theorem}
		Computing $h^+$ is co-NEXPTime-complete.
	\end{theorem}
	
	
	
	\begin{theorem}
		Let \task be a planning task with at least one applicable action in its initial state.
		Then, the optimal repair heuristic value within the delete relaxation is bounded by:
		$$\optimalHeuristicRel(\task) \leq  \arity{\preds}$$
	\end{theorem}
	
	
	
	\section{0-ary and 1-ary Relaxation}
	
	So, 
	we know that computing $h^{+}$ 
	is generally still intractable and heuristic values are low.
	A relaxation that will give us a polynomial time guarantee at the lifted level is the Unary Relxation.
	Its drawback can be seen as simplifying too much leading to too low heuristic values.
	Though, as heuristic values are super low here, it may be not as much of a bottleneck.
	
	\begin{definition}
		The unary relaxation of a predicate $\somePred \in \preds$ is:
		$$
		\unary{\somePred} = \{\somePred_i \mid 1 \leq i \leq \arity{\somePred}\}
		$$
		Which splits the predicate into \arity{\somePred} unary ones.
		The unary relaxation of an atom $\someAtom \in \atoms$ is:
		$$
		\unary{\someAtom} =  \{\somePred_i(\someVar_i) \mid 1 \leq i \leq \arity{\somePred}\}
		$$
		Which splits the atom into its unary predicates.
		The unary relaxation of a set $\someLiftedSet \subseteq \atoms$ is the collection of all its atomic applications
		$
		\unary{\someLiftedSet} =  \bigcup_{\someAtom \in \atoms} \unary{\someAtom}
		$.
		
		The unary relaxation is defined on the top of the delete relaxation and so applies the {$\unary{}$}-operation only over \prename and \delname as
		$$
		\unary{\acts} = \{(\unary{\pre{\someAct}}, \unary{\add{\someAct}}, \emptyset, \cost{\someAct}) \mid \someAct \in \acts\}
		$$.
		The unary relaxed task is then obtained as the application of $\unary{}$ across the whole task:
		$$
		\unary{\task} = (\unary{\preds}, \objects, \unary{\acts}, \unary{\init}, \unary{\goal})
		$$
	\end{definition}
	
	Within this relaxation we can derive admissible heuristics.
	
	\begin{theorem}
		$$
			h^{max}(\unary{\task^{R}}) \leq \optimalHeuristic(\task)
		$$
%		$$
%		h^{add}(\unary{\task^{R}}) \leq \optimalHeuristic(\task)
%		$$
		$$
		h^{lmcut}(\unary{\task^{R}}) \leq \optimalHeuristic(\task)
		$$
	\end{theorem}
	
	And provide a polynomial time guarantee. (TODO cite LAUER 2020,2021)
	
	\begin{theorem}
		$
		h^{max}(\unary{\task^{R}})
		$,
		$
		h^{add}(\unary{\task^{R}})
		$,
		$
		h^{lmcut}(\unary{\task^{R}})
		$
		and 
		$
		h^{F}(\unary{\task^{R}})
		$
		are computable in polynomial time w.r.t.\ the lifted representation.
	\end{theorem}
	
	As the heuristic value is bounded by only the amount of predicates, I was curious what happens if we simply drop all parameters. 
	(Which corresponds to considering predicates.)
	A similar idea was considered by \cite{lei:etal:socs-23} as a novelty measure for actions in a generalized planning context.
	(It's probably not too related, but we should cite it.)
	
	\begin{definition}
		The zeroary relaxation of an atom $\someAtom \in \atoms$ removes its arguments as:
		$$
		\zeroary{\someAtom} =  \somePred()
		$$
		The zeroary relaxation is defined on the top of the delete relaxation and so applies the {$\zeroary{}$}-operation only over \prename and \delname as
		$$
		\zeroary{\acts} = \{(\zeroary{\pre{\someAct}}, \zeroary{\add{\someAct}}, \emptyset, \cost{\someAct}) \mid \someAct \in \acts\}
		$$.
		The unary relaxed task is then obtained as the application of $\unary{}$ across the whole task:
		$$
		\zeroary{\task} = (\zeroary{\preds}, \objects, \zeroary{\acts}, \zeroary{\init}, \zeroary{\goal})
		$$
	\end{definition}
	
	As it is even simpler than the unary relaxation, we can derive the same properties.
	
	\begin{theorem}
		$$
		h^{max}(\zeroary{\task^{R}}) \leq \optimalHeuristic(\task)
		$$
		$$
		h^{lmcut}(\zeroary{\task^{R}}) \leq \optimalHeuristic(\task)
		$$
	\end{theorem}
	
	\begin{theorem}
		$
		h^{max}(\zeroary{\task^{R}})
		$,
		$
		h^{add}(\zeroary{\task^{R}})
		$,
		$
		h^{lmcut}(\zeroary{\task^{R}})
		$
		and 
		$
		h^{F}(\zeroary{\task^{R}})
		$
		are computable in polynomial time w.r.t.\ the lifted representation.
	\end{theorem}
	
	\section{Approach}
	
	I implemented an approach that delete relaxed the task and passes it onto a grounded or lifted planner.
	You can decide if you want to add a unary or zeroary relaxation on top or just stick with the delete relaxation.
	Supported heuristics are the commonly used delete relaxation heuristics $h^{max}$, $h^{add}$, $h^{FF}$, $h^{lmcut}$.
	There are several technical details that can be improved to speed up the implementation.
	Though, for now we should see if the heuristics provide any guidance at all.
		
	\section{Future Ideas / Todos}
	
	\begin{itemize}
		\item Could use a $\task^{m}$ construction that reintroduces (some) of the action effects.
		\item Consider the lifted action sequence provided. E.g. by adding the according lifted preconditions as seperate goals.
		\item Could look for other implementations of delete relaxation heuristics like the $h^{+}$ ones and also reuse these.
		\item There is a lot in the implementation that could be improved.
		\item Need to handle case if initially no action is applicable.
	\end{itemize}
	
	\bibliographystyle{plainnat}
	\bibliography{pbib/books,pbib/journals,pbib/journalsCRef,pbib/proceedings,pbib/proceedingsCRef,pbib/techreport}
	
\end{document}