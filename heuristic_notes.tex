\documentclass[twocolumn]{article}

\usepackage{amsmath}   
\usepackage{xspace}
\usepackage{amssymb}
\usepackage{enumitem}

\newcommand{\task}{\ensuremath{\Pi}\xspace}
\newcommand{\preds}{\ensuremath{\mathcal{P}}\xspace}
\newcommand{\acts}{\ensuremath{\mathcal{A}}\xspace}
\newcommand{\objects}{\ensuremath{\mathcal{O}}\xspace}
\newcommand{\init}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\goal}{\ensuremath{\mathcal{G}}\xspace}
\newcommand{\vars}{\ensuremath{X}\xspace}
\newcommand{\varRepl}{\ensuremath{\theta}\xspace}

\newcommand{\someVar}{\ensuremath{x}\xspace}
\newcommand{\atoms}{\ensuremath{\preds^{\vars}}\xspace}
\newcommand{\someAtom}{\ensuremath{p(\vec{\someVar})}\xspace}
\newcommand{\someLiftedSet}{\ensuremath{L}\xspace}

\newcommand{\somePred}{\ensuremath{p}\xspace}

\newcommand{\states}{\ensuremath{S}\xspace}
\newcommand{\someState}{\ensuremath{s}\xspace}

\newcommand{\prename}{\ensuremath{pre}\xspace}
\newcommand{\addname}{\ensuremath{add}\xspace}
\newcommand{\delname}{\ensuremath{del}\xspace}
\newcommand{\pre}[1]{\ensuremath{\prename(#1)}\xspace}
\newcommand{\add}[1]{\ensuremath{\addname(#1)}\xspace}
\newcommand{\del}[1]{\ensuremath{\delname(#1)}\xspace}
\newcommand{\arity}[1]{\ensuremath{|#1|}}
\newcommand{\cost}[1]{\ensuremath{c(#1)}\xspace}

\newcommand{\fixPre}{\ensuremath{F^{\prename}}\xspace}
\newcommand{\fixAdd}{\ensuremath{F^{\addname}}\xspace}

\newcommand{\someAct}{\ensuremath{a}\xspace}
\newcommand{\someActSeq}{\ensuremath{\pi}\xspace}


\newcommand{\optimalHeuristic}{\ensuremath{h^{*}_{Rep}}\xspace}
\newcommand{\optimalHeuristicSeq}{\ensuremath{h^{*}_{Seq}}\xspace}

\newcommand{\optimalHeuristicRel}{\ensuremath{h^{+}_{Rep}}\xspace}
\newcommand{\optimalHeuristicSeqRel}{\ensuremath{h^{+}_{Seq}}\xspace}

\newcommand{\relaxedActs}{\ensuremath{\acts^{+}}\xspace}
\newcommand{\relaxedTask}{\ensuremath{\task^{+}}\xspace}

\zeroary
\newcommand{\unary}[1]{\ensuremath{#1_{|1}}\xspace}
\newcommand{\zeroary}[1]{\ensuremath{#1_{|0}}\xspace}

\title{Technical Notes for the heuristic in the paper}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}

\begin{document}
	
	\maketitle
	
	\section{Notation}
	
	\begin{itemize}[noitemsep]
		\item \task denotes planning tasks
		\item \preds denotes predicates
		\item \acts denotes (lifted) actions
		\item \objects denotes objects
		\item \init denotes the initial state
		\item \goal denotes goal
		\item \atoms denotes the set of all (lifted) atoms
		\item \varRepl denotes a full variable replacement to ground a structure
		\item $^+$ is associated with the delete relaxation
		\item \fixPre is some set of atomic repairs that delete preconditions
		\item \fixAdd is some set of atomic repairs that add \addname elements
	\end{itemize}
	
	
	\section{Problem Formulation}
	
	\begin{definition}
		Given a planning task \task the optimal repair heuristic $\optimalHeuristic(\task)$ is the minimal amount of repairs to make \task solvable.
	\end{definition}
	
	\begin{definition}
		Given a planning task \task, lifted action sequence \someActSeq the optimal repair sequence heuristic $\optimalHeuristicSeq(\task, \someActSeq)$ is the minimal amount of repairs to make \task solvable via a grounded action sequence $\varRepl(\someActSeq)$ for some variable replacement \varRepl.
	\end{definition}
	
	\begin{proposition}
		Given a planning task \task, lifted action sequence \someActSeq, it holds that:
		$$
		\optimalHeuristic(\task) \leq \optimalHeuristicSeq(\task, \someActSeq)
		$$
		I.e.\ the optimal repair heuristic $\optimalHeuristic(\task)$ is bounded by $\optimalHeuristicSeq(\task, \someActSeq)$.
		This implies that $\optimalHeuristic(\task)$ is an admissible heuristic for the repair problem with a lifted action sequence provided.
	\end{proposition}
	
	\section{Perfect Heuristic}
	
	TODO: delete relaxation is a common choice to make things tractable with heuristics ...
	
	\begin{definition}
		The delete relaxation of a planning task
		$\task = (\preds, \objects, \acts, \init, \goal)$
		is obtained as
		$\relaxedTask = (\preds, \objects, \relaxedActs, \init, \goal)$
		where 
		$$
		\relaxedActs = \{
		(\pre{\someAct}, \add{\someAct}, \emptyset, \cost{\someAct}) \mid \someAct \in \acts
		\}
		$$
		is the set of actions obtained by removing the deletes.
	\end{definition}
	
	\begin{definition}
		For any heuristic $h: \states \rightarrow \mathbb{R}$ the decision problem is:
		Given a state $\someState \in \states$ and $\mathit{val} \in \mathbb{R}$, decide if $h(\someState) = \mathit{val}$.
	\end{definition}
	
	\begin{theorem}
		Computing $h^*$ is EXPTIME??? TODO
	\end{theorem}
	
	
	\begin{proposition}
		For any planning task \task:
		$$\optimalHeuristic(\task) \leq \min_{\someAct \in \acts}(\arity{\pre{\someAct}} + \arity{\del{\someAct}}) + \arity{\preds}$$
		bounds the optimal repair heuristic value.
	\end{proposition}
	
	TODO: expected to be low value ... compared to how hard solving a task ... .
	
	\section{Delete Relaxation Heuristics}
	
	\begin{definition}
		For a planning task \task and action sequence \someActSeq:
		$\optimalHeuristicRel(\task) := \optimalHeuristic(\relaxedTask)$
		and 
		$\optimalHeuristicSeqRel(\task) := \optimalHeuristicSeq(\relaxedTask)$
		denote the optimal heuristics within the delete relaxation.
	\end{definition}
	
	\begin{theorem}
		Computing $h^+$ is EXPTIME??? TODO
	\end{theorem}
	
	
	\begin{corollary}
		For any planning task \task:
		$$\optimalHeuristicRel(\task) \leq \min_{\someAct \in \acts}(\arity{\pre{\someAct}}) + \arity{\preds}$$
		bounds the optimal repair heuristic value within the delete relaxation.
	\end{corollary}
	
	\begin{proposition}
		Let \relaxedTask be a delete relaxed planning task with at least one applicable action in its initial state.
		Let \fixPre be atomic precondition repairs to make the task solvable.
		Then there is a set \fixAdd with $\arity{\fixPre} \leq \arity{\fixAdd}$ that makes the task solvable.
	\end{proposition}
	
	
	\begin{theorem}
		Let \task be a planning task with at least one applicable action in its initial state.
		Then, the optimal repair heuristic value within the delete relaxation is bounded by:
		$$\optimalHeuristicRel(\task) \leq  \arity{\preds}$$
	\end{theorem}
	
	
	
	\section{Task Compilation}
	
	
	\begin{definition}
		
		TODO: task compilation to only add elements 
		$\task = (\preds, \objects, \acts, \init, \goal)$
		is obtained as
		$TODOtask = (\preds, \objects, \acts^0 \cup \acts^{TODOsc}, \init, \goal)$
		where 
		$$
		\acts^0 = \{
		(\pre{\someAct}, \add{\someAct}, \emptyset, 0) \mid \someAct \in \acts
		\}
		$$
		is the set of actions obtained by removing the deletes and setting cost to 0.
		And 
		$$
		\acts^{TODOsc} = 
		= \{
		(SC_ACTIVATED, \add{PRED}, \emptyset, 0) \mid \someAct \in \acts
		\}$$
		... activates ... .
		And TODO
		$$
		 \{
		(\emptyset, SC_ACTIVATED, \emptyset, 1) \mid \someAct \in \acts
		\}
		$$
		is the switch enabling the predicate ... .
	\end{definition}
	
	\begin{theorem}
		Task trasnformation TODO ... 
	\end{theorem}
	
	
	
	\section{0-ary and 1-ary Relaxation}
	
	\begin{definition}
		The unary relaxation of a predicate $\somePred \in \preds$ is:
		$$
		\unary{\somePred} = \{\somePred_i \mid 1 \leq i \leq \arity{\somePred}\}
		$$
		Which splits the predicate into \arity{\somePred} unary ones.
		The unary relaxation of an atom $\someAtom \in \atoms$ is:
		$$
		\unary{\someAtom} =  \{\somePred_i(\someVar_i) \mid 1 \leq i \leq \arity{\somePred}\}
		$$
		Which splits the atom into its unary predicates.
		The unary relaxation of a set $\someLiftedSet \subseteq \atoms$ is the collection of all its atomic applications
		$
		\unary{\someLiftedSet} =  \bigcup_{\someAtom \in \atoms} \unary{\someAtom}
		$.
		
		The unary relaxation is defined on the top of the delete relaxation and so applies the {$\unary{}$}-operation only over \prename and \delname as
		$$
		\unary{\acts} = \{(\unary{\pre{\someAct}}, \unary{\add{\someAct}}, \emptyset, \cost{\someAct}) \mid \someAct \in \acts\}
		$$.
		The unary relaxed task is then obtained as the application of $\unary{}$ across the whole task:
		$$
		\unary{\task} = (\unary{\preds}, \objects, \unary{\acts}, \unary{\init}, \unary{\goal})
		$$
	\end{definition}
	
	\begin{theorem}
		TODO hmax, hadd, hff TODO 
	\end{theorem}
	
	\begin{proof}
		TODO ... link bsc thesis, unary paper
	\end{proof}
	
	
	TODO: explain invention.
	TODO: link lipovetzky paper
	
	\begin{definition}
		The zeroary relaxation of an atom $\someAtom \in \atoms$ removes its arguments as:
		$$
		\zeroary{\someAtom} =  \somePred()
		$$
		The zeroary relaxation is defined on the top of the delete relaxation and so applies the {$\zeroary{}$}-operation only over \prename and \delname as
		$$
		\zeroary{\acts} = \{(\zeroary{\pre{\someAct}}, \zeroary{\add{\someAct}}, \emptyset, \cost{\someAct}) \mid \someAct \in \acts\}
		$$.
		The unary relaxed task is then obtained as the application of $\unary{}$ across the whole task:
		$$
		\zeroary{\task} = (\zeroary{\preds}, \objects, \zeroary{\acts}, \zeroary{\init}, \zeroary{\goal})
		$$
	\end{definition}
	
	What's the motivation?
	TODO: motivate grounding process 
	
	\section{Approach}
	
	TODO: currently implemented is:
		
	\section{Future Ideas}
	
	\begin{itemize}
		\item Could use a $\task^{m}$ construction that reintroduces (some) of the action effects
		\item extend with preconditions of lifted actions -- that's not exactly what you asked for, but could make it to also need to achieve ... 
		\item Could use h+ computations
		\item 
		TODO: what does this value correspond to minimal reachable landmarks? something like that? If yes, can we use LMCUT or the LMCUT like thing malte uses for h+?
	\end{itemize}
	
	
\end{document}