\documentclass[twocolumn]{article}

\usepackage{amsmath}   
\usepackage{xspace}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{mathtools}

\newcommand{\task}{\ensuremath{\Pi}\xspace}
\newcommand{\preds}{\ensuremath{\mathcal{P}}\xspace}
\newcommand{\acts}{\ensuremath{\mathcal{A}}\xspace}
\newcommand{\objects}{\ensuremath{\mathcal{O}}\xspace}
\newcommand{\init}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\goal}{\ensuremath{\mathcal{G}}\xspace}
\newcommand{\vars}{\ensuremath{X}\xspace}
\newcommand{\varRepl}{\ensuremath{\theta}\xspace}

\newcommand{\someVar}{\ensuremath{x}\xspace}
\newcommand{\atoms}{\ensuremath{\preds^{\vars}}\xspace}
\newcommand{\someAtom}{\ensuremath{p(\vec{\someVar})}\xspace}
\newcommand{\someLiftedSet}{\ensuremath{L}\xspace}

\newcommand{\somePred}{\ensuremath{p}\xspace}

\newcommand{\states}{\ensuremath{S}\xspace}
\newcommand{\someState}{\ensuremath{s}\xspace}

\newcommand{\prename}{\ensuremath{pre}\xspace}
\newcommand{\addname}{\ensuremath{add}\xspace}
\newcommand{\delname}{\ensuremath{del}\xspace}
\newcommand{\pre}[1]{\ensuremath{\prename(#1)}\xspace}
\newcommand{\add}[1]{\ensuremath{\addname(#1)}\xspace}
\newcommand{\del}[1]{\ensuremath{\delname(#1)}\xspace}
\newcommand{\arity}[1]{\ensuremath{|#1|}}
\newcommand{\cost}[1]{\ensuremath{c(#1)}\xspace}

\newcommand{\fixPre}{\ensuremath{F^{\prename}}\xspace}
\newcommand{\fixAdd}{\ensuremath{F^{\addname}}\xspace}

\newcommand{\someAct}{\ensuremath{a}\xspace}
\newcommand{\someActSeq}{\ensuremath{\pi}\xspace}


\newcommand{\optimalHeuristic}{\ensuremath{h^{*}_{Rep}}\xspace}
\newcommand{\optimalHeuristicSeq}{\ensuremath{h^{*}_{Seq}}\xspace}

\newcommand{\optimalHeuristicRel}{\ensuremath{h^{+}_{Rep}}\xspace}
\newcommand{\optimalHeuristicSeqRel}{\ensuremath{h^{+}_{Seq}}\xspace}

\newcommand{\relaxedActs}{\ensuremath{\acts^{+}}\xspace}
\newcommand{\relaxedTask}{\ensuremath{\task^{+}}\xspace}

\newcommand{\unary}[1]{\ensuremath{#1_{|1}}\xspace}
\newcommand{\zeroary}[1]{\ensuremath{#1_{|0}}\xspace}

\title{Technical Notes for the heuristic in the paper}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}

\begin{document}
	
	\maketitle
	
	\section{Introduction}
	
	TODO: 
	just formalize so that we know we are on the same page
	introduce the necesscary background
	
	motivate the choices i made 
	
	and list some observations i made
	
	further lsit what's actually implemented
	
	The proofs are not inteded to be elaborate ideas but rather just sketches of the main idea, all statements are rather trivial
	
	\section{Notation}
	
	\begin{itemize}[noitemsep]
		\item \task denotes planning tasks
		\item \preds denotes predicates
		\item \acts denotes (lifted) actions
		\item \objects denotes objects
		\item \init denotes the initial state
		\item \goal denotes goal
		\item \atoms denotes the set of all (lifted) atoms
		\item \varRepl denotes a full variable replacement to ground a structure
		\item $^+$ is associated with the delete relaxation
		\item \fixPre is some set of atomic repairs that delete preconditions
		\item \fixAdd is some set of atomic repairs that add \addname elements
	\end{itemize}
	
	
	\section{Problem Formulations and Perfect Heuristics}
	
	Let's start by formalizing the perfect heuristic for both settings.
	
	\begin{definition}
		Given a planning task \task the optimal repair heuristic $\optimalHeuristic(\task)$ is the minimal amount of repairs to make \task solvable.
	\end{definition}
	
	\begin{definition}
		Given a planning task \task, lifted action sequence \someActSeq the optimal repair sequence heuristic $\optimalHeuristicSeq(\task, \someActSeq)$ is the minimal amount of repairs to make \task solvable via a grounded action sequence $\varRepl(\someActSeq)$ for some variable replacement \varRepl.
	\end{definition}
	
	This is particularly important, as we are looking for an admissible heuristic, which is defined w.r.t. to the perfect heuristic.
	
	\begin{definition}
		A heuristic $h$ is called admissible for the optimal repair problem if for all planning tasks \task it holds that. $h(\task) \leq \optimalHeuristic(\task)$. 
	\end{definition}
	
	\begin{definition}
		A heuristic $h$ is called admissible for the optimal repair sequence problem if for all planning tasks \task, lifted action sequences \someActSeq it holds that. $h(\task, \someActSeq) \leq \optimalHeuristicSeq(\task, \someActSeq)$. 
	\end{definition}
	
	We can make the instant observation that a given sequence can only increase the perfect heuristic value and so ignoring the sequence can yield an admissible heuristic estimate.
	
	\begin{proposition}
		Given a planning task \task, lifted action sequence \someActSeq, it holds that:
		$$
		\optimalHeuristic(\task) \leq \optimalHeuristicSeq(\task, \someActSeq)
		$$
		I.e.\ the optimal repair heuristic $\optimalHeuristic(\task)$ is bounded by $\optimalHeuristicSeq(\task, \someActSeq)$.
		This implies that $h(\task, \someActSeq) \coloneqq \optimalHeuristic(\task)$ is an admissible heuristic for the repair problem with a lifted action sequence provided.
	\end{proposition}
	
	\section{Feasibility of Computing the Perfect Heuristics}
	
	TODO: standard argument that it is hard to compute the heuristic.
	
	\begin{definition}
		For any heuristic $h: \states \rightarrow \mathbb{R}$ the decision problem is:
		Given a state $\someState \in \states$ and $\mathit{val} \in \mathbb{R}$, decide if $h(\someState) = \mathit{val}$.
	\end{definition}
	
	\begin{theorem}
		Computing $h^*$ is EXPTIME??? TODO
	\end{theorem}
	
	\begin{proof}
		TODO
	\end{proof}
	
	
	TODO:
	On top of that as plan sizes low, heuristic values are low ... so maybe can be more 
	abstract / relaxing
	
	\begin{proposition}
		For any planning task \task:
		$$\optimalHeuristic(\task) \leq \min_{\someAct \in \acts}(\arity{\pre{\someAct}} + \arity{\del{\someAct}}) + \arity{\preds}$$
		bounds the optimal repair heuristic value.
	\end{proposition}
	
	\begin{proof}
		TODO
	\end{proof}
	
	
	\section{Delete Relaxation Heuristics}
	
	TODO: delete relaxation is a common choice to make things tractable with heuristics ...
	
	\begin{definition}
		The delete relaxation of a planning task
		$\task = (\preds, \objects, \acts, \init, \goal)$
		is obtained as
		$\relaxedTask = (\preds, \objects, \relaxedActs, \init, \goal)$
		where 
		$$
		\relaxedActs = \{
		(\pre{\someAct}, \add{\someAct}, \emptyset, \cost{\someAct}) \mid \someAct \in \acts
		\}
		$$
		is the set of actions obtained by removing the deletes.
	\end{definition}
	
	\begin{definition}
		For a planning task \task and action sequence \someActSeq:
		$\optimalHeuristicRel(\task) := \optimalHeuristic(\relaxedTask)$
		and 
		$\optimalHeuristicSeqRel(\task) := \optimalHeuristicSeq(\relaxedTask)$
		denote the optimal heuristics within the delete relaxation.
	\end{definition}
	
	\begin{theorem}
		Computing $h^+$ is EXPTIME??? TODO
	\end{theorem}
	
	
	\section{Task Compilation}
	
	TODO: short intution what's done here
	
	\begin{definition}
		
		TODO: task compilation to only add elements 
		$\task = (\preds, \objects, \acts, \init, \goal)$
		is obtained as
		$\task^{R} = (\preds, \objects, \acts^0 \cup \acts^{R}, \init, \goal)$
		where 
		$$
		\acts^0 = \{
		(\pre{\someAct}, \add{\someAct}, \emptyset, 0) \mid \someAct \in \acts
		\}
		$$
		is the set of actions obtained by removing the deletes and setting cost to 0.
		And the repair actions $\acts^{R} = \acts^{R}_1 \cup \acts^{R}_2$ are composed by:
		$$
		\acts^{R}_1 = 
		\{
		(\emptyset, \{\text{activate\_}\somePred\}, \emptyset, 1) \mid \somePred \in \preds
		\}
		$$
		the actions selecting which \addname repairs are selected.
		$$
		\acts^{R}_2
		= \{
		(\{\text{activate\_}\somePred\}, \{\someAtom\}, \emptyset, 0) \mid \somePred \in \preds
		\}$$
		that allow to achieve any atom for the corresponding repair.
	\end{definition}
	
	\begin{theorem}
		Task trasnformation value matches if one applicable ...
		
		Otherwise 
		TODO: if no action applicable in the beginning ... add reapirs can't help
	\end{theorem}
	
	
	\section{Feasibility of Computing the Perfect Delete Relaxation Heuristics}
	
	
	\begin{corollary}
		For any planning task \task:
		$$\optimalHeuristicRel(\task) \leq \min_{\someAct \in \acts}(\arity{\pre{\someAct}}) + \arity{\preds}$$
		bounds the optimal repair heuristic value within the delete relaxation.
	\end{corollary}
	
	\begin{proposition}
		Let \relaxedTask be a delete relaxed planning task with at least one applicable action in its initial state.
		Let \fixPre be atomic precondition repairs to make the task solvable.
		Then there is a set \fixAdd with $\arity{\fixPre} \leq \arity{\fixAdd}$ that makes the task solvable.
	\end{proposition}
	
	
	\begin{theorem}
		Let \task be a planning task with at least one applicable action in its initial state.
		Then, the optimal repair heuristic value within the delete relaxation is bounded by:
		$$\optimalHeuristicRel(\task) \leq  \arity{\preds}$$
	\end{theorem}
	
	
	
	\section{0-ary and 1-ary Relaxation}
	
	BOTH motivates we need more relaxation
	
	\begin{definition}
		The unary relaxation of a predicate $\somePred \in \preds$ is:
		$$
		\unary{\somePred} = \{\somePred_i \mid 1 \leq i \leq \arity{\somePred}\}
		$$
		Which splits the predicate into \arity{\somePred} unary ones.
		The unary relaxation of an atom $\someAtom \in \atoms$ is:
		$$
		\unary{\someAtom} =  \{\somePred_i(\someVar_i) \mid 1 \leq i \leq \arity{\somePred}\}
		$$
		Which splits the atom into its unary predicates.
		The unary relaxation of a set $\someLiftedSet \subseteq \atoms$ is the collection of all its atomic applications
		$
		\unary{\someLiftedSet} =  \bigcup_{\someAtom \in \atoms} \unary{\someAtom}
		$.
		
		The unary relaxation is defined on the top of the delete relaxation and so applies the {$\unary{}$}-operation only over \prename and \delname as
		$$
		\unary{\acts} = \{(\unary{\pre{\someAct}}, \unary{\add{\someAct}}, \emptyset, \cost{\someAct}) \mid \someAct \in \acts\}
		$$.
		The unary relaxed task is then obtained as the application of $\unary{}$ across the whole task:
		$$
		\unary{\task} = (\unary{\preds}, \objects, \unary{\acts}, \unary{\init}, \unary{\goal})
		$$
	\end{definition}
	
	\begin{theorem}
		TODO hmax, hadd, hff TODO 
	\end{theorem}
	
	\begin{proof}
		TODO ... link bsc thesis, unary paper
	\end{proof}
	
	
	TODO: explain invention.
	TODO: link lipovetzky paper
	
	\begin{definition}
		The zeroary relaxation of an atom $\someAtom \in \atoms$ removes its arguments as:
		$$
		\zeroary{\someAtom} =  \somePred()
		$$
		The zeroary relaxation is defined on the top of the delete relaxation and so applies the {$\zeroary{}$}-operation only over \prename and \delname as
		$$
		\zeroary{\acts} = \{(\zeroary{\pre{\someAct}}, \zeroary{\add{\someAct}}, \emptyset, \cost{\someAct}) \mid \someAct \in \acts\}
		$$.
		The unary relaxed task is then obtained as the application of $\unary{}$ across the whole task:
		$$
		\zeroary{\task} = (\zeroary{\preds}, \objects, \zeroary{\acts}, \zeroary{\init}, \zeroary{\goal})
		$$
	\end{definition}
	
	What's the motivation?
	TODO: motivate grounding process 
	
	\section{Approach}
	
	TODO: currently implemented is:
	
	
	A lot of room for improvement -- Maybe we should add this to an issue:
	\begin{itemize}
		\item deep-copy:
		\item TODO
	\end{itemize}
		
	\section{Future Ideas}
	
	\begin{itemize}
		\item Could use a $\task^{m}$ construction that reintroduces (some) of the action effects
		\item extend with preconditions of lifted actions -- that's not exactly what you asked for, but could make it to also need to achieve ... 
		\item Could use h+ computations
		\item 
		TODO: what does this value correspond to minimal reachable landmarks? something like that? If yes, can we use LMCUT or the LMCUT like thing malte uses for h+?
	\end{itemize}
	
	
\end{document}