# a working example we have used, as a reference
successor_generator: missing
use_ff: True
search_algorithm: ucs
heuristic_relaxation: unary
lift_prob: 0.33
min_length: 1
max_length: 15
timeout_seconds: 900  # 15 minutes * 60 seconds/minute
order: increasing
benchmark_path: input/benchmarks-G1
log_folder: exp_logs_debug/
log_interval: 1000000
domain_class: null


###### Supported Values
# search_algorithm:
#   g_astar: greedy_astar
#   astar
#   bfs: Uniform Cost Search (note that "bfs" can be misleading, and we will refactor the code to rename it to ucs later.)
#   greedy
#   dfs
#   bb: branch & bound

# successor_generator: 'missing', 'missing-and-negative', 'exhaust'
# they correspond to RELAX_PRE, RELAX_DEL, and EXHAUST in the paper, respectively.

# heuristic_relaxation: zeroary, null, unary
# lift_prob: (0 to 1.0). We use this variable as the probability of turning each action parameter from an object to a variable. 1 means all objects in the action traces will turn into variables, 0 means they will remain grounded.
# min_length & max_length: integers greater than zero. They are used to filter the benchmark for problems that have a action trace with specified length bounds.
# timeout_seconds: max_time for the search per instance in seconds.
# log_interval: how frequently the details of the search variables will be logged. Use small values for debugging. Use large values (e.g. 1000000) for other purposes.
# order: can be "increasing" or "random" (without double-quotes). Increasing means that problems with smaller length of action traces will be solved first.
# benchmark_path: The path that holds the problems to be solved. The folder structure should be similar to the benchmark we used. Refer to readme.md for more information. #TODO add this to readme.
# log_folder: the folder that log files will be saved to.
# domain_class: "null" or the name of the domain (e.g. "mprime"). We mostly used this for testing on a subset of our benchmarks. For the end user can simply be null.

